/* 
 * Title: 22-tunes
 * Author: P Flynn
 * Date: 22-Sep-2025
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <neo/graphics.h>
#include <neo/console.h>
#include <neo/sound.h>
#include <neo/file.h>
#include <neo/system.h>

#include "note.h"

#define TRUE (0==0)
#define FALSE (0==1)

uint16_t read_line(uint8_t chan,char *buf) { // returns length
  uint16_t l=0;
  while (1==1) {
    char c;
    if (neo_file_eof(chan)) break;
    neo_file_read(chan,&c,1);
    buf[l++]=c;
    if (c == '\n') break;
    }
  if (l) // if file was not empty
    buf[l++]=0;
  return l;
  }

uint16_t findpitch(char *nn) {
  uint16_t i;
  for(i=0;i<sizeof(pitch);i++) {
    if (!strcmp(nn,pitch[i].name)) break;
    }
  if (i==sizeof(pitch)) {
    printf("Error: failed to find pitch for note named %s\n",nn);
    exit(-1);
    }
  return pitch[i].pitch;
  }

note_t song[2000];
uint16_t n_notes;

void wait_for_time(unsigned long t) {
  while (neo_system_timer() < t) /* wait */ ;
  }

#define WAITKEY ; //{while(!neo_console_read_char()) ;}

// no strtod, no atof, the API call doesn't work... sigh.
// return the integer containing 100 times the float represented by the string
uint16_t str_to_int_x100(char *str) {
  uint16_t res=0;
  char *p=str;

  // accumulate integer part
  while ((*p) && (*p != '.')) {
    res = 10 * res + (*p++ - '0'); // whee!
    }
  if (!(*p)) return (res*100); // no decimal point at all.
  p++;
  if (*p) {
    res = 10*res + (*p++ - '0'); // first digit after decimal pt
    if (*p) {
      res = 10*res + (*p++ - '0'); // second digit after decimal pt
      return res; // there were >=2 digits after decimal pt
      }
    else {
      return (res*10); // only one digit after decimal point
      }
    }
  else {
    return (res*100); // no digits after decimal point, but there was a decimal point
    }
  }

  
int main(void) {
    uint8_t err;
    uint16_t nl=0;
    uint16_t nchan = neo_sound_channel_count();

    neo_file_open(1,"rpgchip01_title_screen_converted.csv",NEO_FILE_READ);
    if ((err=neo_api_error())) {
      printf("neo_file_open(): error %d\n",err);
      exit(-1);
    }
    
    n_notes=0;
    uint16_t ch=0;
    uint32_t oldst=0;

    while (TRUE) {
      // read and parse the notes (one note per line).
      // the csv file is generated by a web app 
      // (https://midi-to-csv.vercel.app/)
      // the layout for each line (there is a header line) is
      // Track,Event Type,Midi Note,Note Name,Velocity,Duration (seconds),Time (seconds)
      // Track, Event Type, Midi Note, Velocity are ignored.
      char line[128],*p;
      float st,dur;
      uint16_t l = read_line(1,line);
      printf("%d (ch %d): %s\n",nl,ch,line);
      if (!l) break;
      //if (nl > 10) break;
      if (nl++ == 0) continue; // skip header
      p = strtok(line,","); // track
      p = strtok(NULL,","); // et
      p = strtok(NULL,","); // midi note
      p = strtok(NULL,","); // note name
      uint16_t npitch=findpitch(p); // corresponding pitch
      //printf("pitch %d\n",npitch);
      song[n_notes].pitch = npitch;
      p = strtok(NULL,","); // vel
      p = strtok(NULL,","); // dur
      song[n_notes].duration = str_to_int_x100(p);
      p = strtok(NULL,",\n\r"); // time
      song[n_notes].start_time = st = str_to_int_x100(p);
      if (st == oldst) {
        song[n_notes].channel = ch++;
        if (ch>nchan) {
          printf("Error: ran out of channels!\n");
          exit(-1);
          }
        }
      if (st < oldst) {
        printf("ERROR: song notes not sorted by time.\n");
        exit(-1);
        }
      if (st > oldst) {
        oldst = st;
        ch = 0;
        song[n_notes].channel = ch;
        }
      PRINTNOTE(&song[n_notes]);
      WAITKEY;
      n_notes++;
      }
    printf("Read %d lines, %d notes.\n",nl,n_notes);

    // the song is in memory (ick). Play it.
    // this turns out to be a typical CS scheduling problem. You have 'nchannels' different
    // note players, and want to schedule the notes to play on an open player, for the note's
    // specified duration.

    // the first thing to do is check feasibility (this is ideally done while reading the file,
    // and indeed part of this IS done when reading, by barfing if there are > nchannels notes
    // starting at the same time - but there are cases where N > nchannels
    // notes start at different times, but all overlap in time -- not feasible, but also not
    // detected with the static check above). 

    // the idea here is to check each start time and find out how many notes are active at
    // that time.

    for(uint16_t i=0;i<n_notes;i++) {
      uint32_t st = song[i].start_time;
      uint16_t j;
      if (i<n_notes-1) {
        for(j=i+1;i<n_notes;j++)
          if (song[j].start_time != st) break;
        if (j<n_notes) { // multiple notes same start time. how many?
          if ((j-i) > nchan) { // barf
            printf("Error: notes %d to %d all have the same start time, only %d chans available\n",i,j,nchan);
            exit(-1);
            }
          }
        }
      }
        
    unsigned long t0 = neo_system_timer();
    uint16_t i;

    for (i=0;i<n_notes;i++) {
      note_t *p = &song[i];
      wait_for_time(t0+p->start_time);
      printf("queue "); PRINTNOTE(p);
      neo_sound_queue((uint8_t)p->channel,(uint16_t)p->pitch,(uint16_t)p->duration,(uint16_t)0,(uint8_t)0);
      }
   } 
