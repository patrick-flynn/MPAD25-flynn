/* 
 * Title: 22-tunes
 * Author: P Flynn
 * Date: 22-Sep-2025
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <neo/graphics.h>
#include <neo/console.h>
#include <neo/sound.h>
#include <neo/file.h>
#include <neo/system.h>

#include "note.h"

// &*$*&^ #include "math.h"

#define SC_W 320
#define SC_H 240

#define TRUE (0==0)
#define FALSE (0==1)

uint16_t read_line(uint8_t chan,char *buf) { // returns length
  uint16_t l=0;
  while (1==1) {
    char c;
    if (neo_file_eof(chan)) break;
    neo_file_read(chan,&c,1);
    buf[l++]=c;
    if (c == '\n') break;
    }
  if (l) // if file was not empty
    buf[l++]=0;
  return l;
  }

uint16_t findpitch(char *nn) {
  uint16_t i;
  for(i=0;i<sizeof(pitch);i++) {
    if (!strcmp(nn,pitch[i].name)) break;
    }
  if (i==sizeof(pitch)) {
    printf("Error: failed to find pitch for note named %s\n",nn);
    exit(-1);
    }
  return pitch[i].pitch;
  }

note_t song[2000];
uint16_t n_notes;

void wait_for_time(unsigned long t) {
  while (neo_system_timer() < t) /* wait */ ;
  }

#define WAITKEY ; //{while(!neo_console_read_char()) ;}

// no strtod, no atof, the API call doesn't work... sigh.
// return the integer containing 100 times the float represented by the string
uint16_t str_to_int_x100(char *str) {
  uint16_t res=0;
  char *p=str;

  //printf("str %s\n",str);
  // accumulate integer part
  while ((*p) && (*p != '.')) {
    //printf("res is %lu, consume %c (0x%02x)\n",res,*p,*p);
    res = 10 * res + (*p++ - '0'); // whee!
    //printf("res now %lu\n",res);
    }
  if (!(*p)) return (res*100); // no decimal point at all.
  p++;
  if (*p) {
    //printf("2res is %lu, consume %c\n",res,*p);
    res = 10*res + (*p++ - '0'); // first digit after decimal pt
    //printf("2res now %lu\n",res);
    if (*p) {
      //printf("3res is %lu, consume %c\n",res,*p);
      res = 10*res + (*p++ - '0'); // second digit after decimal pt
      //printf("3res now %lu\n",res);
      return res; // there were >=2 digits after decimal pt
      }
    else {
      return (res*10); // only one digit after decimal point
      }
    }
  else {
    return (res*100); // no digits after decimal point, but there was a decimal point
    }
  }

  
int main(void) {
    uint8_t err;
    uint16_t nl=0;
    uint16_t nchan = neo_sound_channel_count();

    neo_file_open(1,"rpgchip01_title_screen_converted.csv",NEO_FILE_READ);
    if ((err=neo_api_error())) {
      printf("neo_file_open(): error %d\n",err);
      exit(-1);
    }
    
    n_notes=0;
    uint16_t ch=0;
    uint32_t oldst=0;

    while (TRUE) {
      printf("7ch %d\n",ch);
      // read and parse the notes (one note per line).
      // the csv file is generated by a web app 
      // (https://midi-to-csv.vercel.app/)
      // the layout for each line (there is a header line) is
      // Track,Event Type,Midi Note,Note Name,Velocity,Duration (seconds),Time (seconds)
      // Track, Event Type, Midi Note, Velocity are ignored.
      char line[128],*p;
      float st,dur;
      uint16_t l = read_line(1,line);
      printf("8ch %d\n",ch);
      printf("%d (ch %d): %s\n",nl,ch,line);
      if (!l) break;
      //if (nl > 10) break;
      if (nl++ == 0) continue; // skip header
      p = strtok(line,","); // track
      p = strtok(NULL,","); // et
      p = strtok(NULL,","); // midi note
      p = strtok(NULL,","); // note name
      uint16_t npitch=findpitch(p); // corresponding pitch
      printf("pitch %d\n",npitch);
      song[n_notes].pitch = npitch;
      p = strtok(NULL,","); // vel
      p = strtok(NULL,","); // dur
      printf("durstr %s\n",p);
      //float f_dur = neo_math_string_to_number(p);
      //song[n_notes].duration = 100*f_dur;
      song[n_notes].duration = str_to_int_x100(p);
      printf("durx100 %d\n",song[n_notes].duration);
      p = strtok(NULL,",\n\r"); // time
      printf("st_str %s\n",p);
      //float f_st = neo_math_string_to_number(p);
      //song[n_notes].start_time = 100*f_st;
      song[n_notes].start_time = st = str_to_int_x100(p);
      printf("stx100 %lu\n",song[n_notes].start_time);
      printf("1ch %d\n",ch);
      if (st == oldst) {
        song[n_notes].channel = ch++;
        if (ch>nchan) {
          printf("Error: ran out of channels!\n");
          ch--; // barf
          printf("2ch %d\n",ch);
          }
        }
      printf("3ch %d\n",ch);
      if (st < oldst) {
        printf("ERROR: song notes not sorted by time.\n");
        exit(-1);
        }
      if (st > oldst) {
        oldst = st;
        ch = 0;
        printf("4ch %d\n",ch);
        song[n_notes].channel = ch;
        }
      PRINTNOTE(&song[n_notes]);
      WAITKEY;
      n_notes++;
      printf("6ch %d\n",ch);
      }
    printf("Read %d lines, %d notes.\n",nl,n_notes);

    // the song is in memory (ick). Play it.
    // the control algorithm is simple because the notes are sorted by start time, hopefully
    // (XXX should check this!)
    // we run the notes in order. If the start time is in the future, wait for it. if not, issue
    // the note.

    unsigned long t0 = neo_system_timer();
    uint16_t i;

    for (i=0;i<n_notes;i++) {
      note_t *p = &song[i];
      wait_for_time(t0+p->start_time);
      printf("queue "); PRINTNOTE(p);
      neo_sound_queue((uint8_t)p->channel,(uint16_t)p->pitch,(uint16_t)p->duration,(uint16_t)0,(uint8_t)0);
      }
   } 
